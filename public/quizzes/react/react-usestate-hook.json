{
  "title": "useState",
  "description": "A 10-question quiz to test your knowledge of the React useState hook.",
  "time": "10 minutes",
  "questions": [
    {
      "id": 1,
      "question": "What does the useState hook allow you to do?",
      "options": [
        "Perform side effects",
        "Add state to functional components",
        "Access the DOM directly",
        "Share state globally"
      ],
      "answer": 1,
      "explanation": "The `useState` hook allows you to add state to functional components. Before hooks were introduced, state could only be used in class components. `useState` enables functional components to have their own local state, which can be updated and will trigger a re-render of the component when changed. This is fundamental for creating interactive and dynamic user interfaces in React."
    },
    {
      "id": 2,
      "question": "What does useState return?",
      "options": [
        "Only the current state value",
        "Only a function to update state",
        "An array with the current state and a setter function",
        "An object with multiple states"
      ],
      "answer": 2,
      "explanation": "`useState` returns an array with two elements: the current state value and a function to update it. This pattern is called array destructuring. For example, `const [count, setCount] = useState(0)` assigns the current state value to `count` and the setter function to `setCount`. This allows you to name your state variables anything you want, making your code more readable."
    },
    {
      "id": 3,
      "question": "In const [count, setCount] = useState(0), what does 0 represent?",
      "options": [
        "The step size of the counter",
        "The ID of the state variable",
        "The initial state value",
        "The maximum value allowed"
      ],
      "answer": 2,
      "explanation": "In `const [count, setCount] = useState(0)`, the `0` represents the initial state value. This is the value that the state variable (`count` in this case) will have on the first render of the component. You can pass any value or type as the initial state, including objects, arrays, or functions."
    },
    {
      "id": 4,
      "question": "How should you update state with useState?",
      "options": [
        "Directly assign a new value to the state variable",
        "Call the setter function returned by useState",
        "Use this.setState()",
        "Modify props"
      ],
      "answer": 1,
      "explanation": "You should update state with `useState` by calling the setter function returned by the hook. Directly assigning a new value to the state variable will not trigger a re-render and won't update the component. The setter function ensures React knows the state has changed and needs to re-render the component. For example, if you have `const [count, setCount] = useState(0)`, you would update the state by calling `setCount(newValue)`."
    },
    {
      "id": 5,
      "question": "What happens if you update state with the same value as before?",
      "options": [
        "The component still re-renders",
        "React skips the re-render for performance",
        "React throws an error",
        "The old value is removed"
      ],
      "answer": 1,
      "explanation": "If you update state with the same value as before, React skips the re-render for performance optimization. React uses a process called reconciliation to determine if a re-render is necessary. If the new state value is the same as the previous value (using Object.is comparison), React will not trigger a re-render, which helps optimize performance."
    },
    {
      "id": 6,
      "question": "Can you use multiple useState hooks in a single component?",
      "options": [
        "No, only one is allowed",
        "Yes, you can use as many as needed",
        "Yes, but only up to two per component",
        "Yes, but they must be in a loop"
      ],
      "answer": 1,
      "explanation": "Yes, you can use multiple `useState` hooks in a single component. React allows you to use as many state hooks as you need. This is one of the advantages of hooks - you can organize your state logically by feature or concern rather than having a single state object. Each call to `useState` creates an independent state variable with its own setter function."
    },
    {
      "id": 7,
      "question": "When updating state based on the previous value, what should you pass to the setter?",
      "options": [
        "A string",
        "A callback function that receives the previous value",
        "The component props",
        "Nothing, React handles it automatically"
      ],
      "answer": 1,
      "explanation": "When updating state based on the previous value, you should pass a callback function (also called an updater function) to the setter. This function receives the previous state value as its argument and should return the new state value. This approach is important when the new state depends on the previous state, as it ensures you're working with the most recent state value. For example: `setCount(prevCount => prevCount + 1)`."
    },
    {
      "id": 8,
      "question": "What happens if you call a state setter function multiple times in the same render cycle?",
      "options": [
        "Each update runs independently",
        "React batches updates and applies the latest value",
        "The component crashes",
        "Only the first update is applied"
      ],
      "answer": 1,
      "explanation": "If you call a state setter function multiple times in the same render cycle, React batches these updates and applies them together. In React 18 and later, all state updates are automatically batched, regardless of where they originate from. This means that multiple calls to the setter function will result in a single re-render with the final state value, improving performance by reducing the number of renders."
    },
    {
      "id": 9,
      "question": "Is useState synchronous or asynchronous?",
      "options": [
        "Synchronous, state updates happen immediately",
        "Asynchronous, updates may not happen right away",
        "It depends on the browser",
        "It depends on the initial value"
      ],
      "answer": 1,
      "explanation": "`useState` is asynchronous, meaning state updates may not happen immediately. When you call a state setter function, React schedules the update, but doesn't apply it immediately. This is why you shouldn't rely on the state value being updated right after calling the setter function. If you need to compute the next state based on the previous state, you should use the functional update form (a callback function) to ensure you're working with the correct previous value."
    },
    {
      "id": 10,
      "question": "Can you initialize useState with a function?",
      "options": [
        "No, it only accepts primitive values",
        "Yes, but the function runs every render",
        "Yes, and React only calls it once to set the initial state",
        "Yes, but only for numbers"
      ],
      "answer": 2,
      "explanation": "Yes, you can initialize `useState` with a function, and React will only call it once to set the initial state. This is called 'lazy initialization' and is useful when the initial state requires an expensive computation. The function is only called during the initial render, and its return value is used as the initial state. For example: `const [state, setState] = useState(() => computeExpensiveValue())`."
    }
  ]
}
