{
  "title": "React Hooks Basics",
  "description": "A 20-question quiz to test your knowledge of React Hooks.",
  "headerimage": "/react/head.png",
  "time": "15 minutes",
  "questions": [
    {
      "id": 1,
      "question": "What is the main purpose of React Hooks?",
      "options": [
        "To make websites load faster",
        "To add state and lifecycle features to functional components",
        "To style components",
        "To connect to a database"
      ],
      "answer": 1,
      "explanation": "React Hooks were introduced to allow functional components to use state and lifecycle methods that were previously only available in class components. This enables developers to write more concise and reusable code without needing to convert functional components to class components."
    },
    {
      "id": 2,
      "question": "Which hook is used to create state in a functional component?",
      "options": ["useState", "useEffect", "useContext", "useReducer"],
      "answer": 0,
      "explanation": "`useState` is the hook used to add state to functional components. It allows you to declare state variables that can be updated and will trigger a re-render of the component when changed."
    },
    {
      "id": 3,
      "question": "What does the <code>useState</code> hook return?",
      "options": [
        "Just the current state value",
        "A function that changes the state",
        "An array with the state value and a function to update it",
        "An object with multiple state variables"
      ],
      "answer": 2,
      "explanation": "`useState` returns an array with two elements: the current state value and a function to update it. This pattern allows you to name your state variables anything you want, and it ensures immutability by requiring the setter function to update the state."
    },
    {
      "id": 4,
      "question": "What does the <code>0</code> represent in this hook call?",
      "example": "<div class='quiz-code-dark'><pre><span class='keyword'>const</span> [count, setCount] = <span class='function'>useState</span>(<span class='number'>0</span>);</pre></div>",
      "options": [
        "The name of the state",
        "The default/initial value of the state",
        "The maximum value allowed",
        "The ID of the component"
      ],
      "answer": 1,
      "explanation": "In `useState(0)`, the `0` represents the initial value of the state. This is the value that the state will have on the first render of the component."
    },
    {
      "id": 5,
      "question": "What problem does this code have?",
      "example": "<div class='quiz-code-dark'><pre><span class='keyword'>function</span> <span class='function'>Timer</span>() {\n  <span class='keyword'>const</span> [seconds, setSeconds] = <span class='function'>useState</span>(<span class='number'>0</span>);\n\n  <span class='function'>setInterval</span>(() => {\n    <span class='function'>setSeconds</span>(seconds + <span class='number'>1</span>);\n  }, <span class='number'>1000</span>);\n\n  <span class='keyword'>return</span> <span class='jsx-tag'>&lt;div&gt;</span>Seconds: {seconds}<span class='jsx-tag'>&lt;/div&gt;</span>;\n}</pre></div>",
      "options": [
        "It updates the state too frequently",
        "The timer isn't being cleaned up properly",
        "It creates a new interval on every render, causing memory leaks",
        "The seconds variable isn't declared properly"
      ],
      "answer": 2,
      "explanation": "This code creates a new interval on every render. Since the component re-renders when state changes, and the interval changes the state, this creates an infinite loop of new intervals. Additionally, none of these intervals are ever cleaned up, causing serious memory leaks.",
      "exampleExplanation": "<div class='quiz-code-dark'><pre><span class='keyword'>function</span> <span class='function'>Timer</span>() {\n  <span class='keyword'>const</span> [seconds, setSeconds] = <span class='function'>useState</span>(<span class='number'>0</span>);\n\n  <span class='keyword'>useEffect</span>(() => {\n    <span class='keyword'>const</span> interval = <span class='function'>setInterval</span>(() => {\n      <span class='function'>setSeconds</span>(prevSeconds => prevSeconds + <span class='number'>1</span>);\n    }, <span class='number'>1000</span>);\n    \n    <span class='keyword'>return</span> () => <span class='function'>clearInterval</span>(interval);\n  }, []);\n\n  <span class='keyword'>return</span> <span class='jsx-tag'>&lt;div&gt;</span>Seconds: {seconds}<span class='jsx-tag'>&lt;/div&gt;</span>;\n}</pre></div>"
    },
    {
      "id": 6,
      "question": "When does useEffect run by default?",
      "example": "<div class='quiz-code-dark'><pre><span class='keyword'>function</span> <span class='function'>MyComponent</span>() {\n  <span class='keyword'>const</span> [count, setCount] = <span class='function'>useState</span>(<span class='number'>0</span>);\n\n  <span class='keyword'>useEffect</span>(() => {\n    <span class='function'>console</span>.<span class='function'>log</span>(<span class='string'>'Effect ran!'</span>);\n  });\n\n  <span class='keyword'>return</span> (\n    <span class='jsx-tag'>&lt;div&gt;</span>\n      <span class='jsx-tag'>&lt;p&gt;</span>Count: {count}<span class='jsx-tag'>&lt;/p&gt;</span>\n      <span class='jsx-tag'>&lt;button</span> <span class='jsx-attribute'>onClick</span>=<span class='jsx-expression'>{() => <span class='function'>setCount</span>(count + <span class='number'>1</span>)}</span><span class='jsx-tag'>&gt;</span>\n        Increment\n      <span class='jsx-tag'>&lt;/button&gt;</span>\n    <span class='jsx-tag'>&lt;/div&gt;</span>\n  );\n}</pre></div>",
      "options": [
        "Only once when the app starts",
        "After every render",
        "Before the component renders",
        "Only when state updates"
      ],
      "answer": 1,
      "explanation": "By default, `useEffect` runs after every render of the component. This includes the initial render and all subsequent updates. You can control when it runs by specifying dependencies in the dependency array.",
      "exampleExplanation": "<div class='quiz-code-dark'><pre><span class='keyword'>useEffect</span>(() => {\n  <span class='comment'>// This runs after every render</span>\n  <span class='function'>console</span>.<span class='function'>log</span>(<span class='string'>'After every render'</span>);\n});\n\n<span class='keyword'>useEffect</span>(() => {\n  <span class='comment'>// This runs only after the initial render</span>\n  <span class='function'>console</span>.<span class='function'>log</span>(<span class='string'>'Only once on mount'</span>);\n}, []);\n\n<span class='keyword'>useEffect</span>(() => {\n  <span class='comment'>// This runs when count changes</span>\n  <span class='function'>console</span>.<span class='function'>log</span>(<span class='string'>'Count changed to: '</span> + count);\n}, [count]);</pre></div>"
    },
    {
      "id": 7,
      "question": "What does the second argument in <code>useEffect(() => { ... }, [])</code> represent?",
      "options": [
        "It specifies dependencies",
        "It prevents rendering",
        "It changes the return type",
        "It clears state"
      ],
      "answer": 0,
      "explanation": "The second argument in `useEffect` is the dependency array. It specifies which values the effect depends on. If any of these values change between renders, the effect will run again. An empty array `[]` means the effect runs only once after the initial render."
    },
    {
      "id": 8,
      "question": "If the dependency array [] in useEffect is empty, when will the effect run?",
      "options": [
        "Never",
        "Once, when the component mounts",
        "On every state change",
        "Every second"
      ],
      "answer": 1,
      "explanation": "If the dependency array in `useEffect` is empty (`[]`), the effect will run only once, when the component mounts. This mimics the behavior of `componentDidMount` in class components."
    },
    {
      "id": 9,
      "question": "Which hook can store a value that does not cause re-renders when updated?",
      "options": ["useEffect", "useRef", "useState", "useMemo"],
      "answer": 1,
      "explanation": "`useRef` is used to store a mutable value that persists across renders without causing a re-render when updated. It is commonly used to access DOM elements or store previous values of state or props."
    },
    {
      "id": 10,
      "question": "Why must hooks always be called at the top level of a component?",
      "options": [
        "To save memory",
        "To keep hooks called in the same order on every render",
        "To shorten code",
        "To prevent side effects"
      ],
      "answer": 1,
      "explanation": "Hooks must be called at the top level of a component to ensure they are called in the same order on every render. This allows React to correctly preserve the state of hooks between multiple useState and useEffect calls."
    },
    {
      "id": 11,
      "question": "Which hook provides context values to child components?",
      "options": ["useContext", "useState", "useReducer", "useEffect"],
      "answer": 0,
      "explanation": "`useContext` allows you to access the value of a React context directly in a functional component. It simplifies the process of consuming context values without needing to render a Context.Consumer component."
    },
    {
      "id": 12,
      "question": "What hook is commonly used to optimize expensive calculations?",
      "options": ["useMemo", "useEffect", "useLayoutEffect", "useReducer"],
      "answer": 0,
      "explanation": "`useMemo` is used to memoize expensive calculations so that they are only recomputed when one of their dependencies changes. This can help optimize performance by avoiding unnecessary recalculations on every render."
    },
    {
      "id": 13,
      "question": "What is the difference between <code>useMemo</code> and <code>useCallback</code>?",
      "options": [
        "<code>useMemo</code> memoizes values, <code>useCallback</code> memoizes functions",
        "They are identical",
        "<code>useCallback</code> is faster than <code>useMemo</code>",
        "<code>useMemo</code> is used for state, <code>useCallback</code> for effects"
      ],
      "answer": 0,
      "explanation": "`useMemo` memoizes values, while `useCallback` memoizes functions. Both hooks are used for performance optimization, but they serve different purposes: `useMemo` caches the result of a function call, while `useCallback` caches the function itself."
    },
    {
      "id": 14,
      "question": "Which hook allows you to manage more complex state logic using a reducer function?",
      "options": ["useReducer", "useEffect", "useMemo", "useContext"],
      "answer": 0,
      "explanation": "`useReducer` is used for managing more complex state logic in a component. It takes a reducer function and an initial state, and returns the current state paired with a dispatch method. It is similar to Redux's use of reducers."
    },
    {
      "id": 15,
      "question": "What function is returned by useReducer?",
      "options": [
        "A function to update context",
        "A function to dispatch actions",
        "A function to re-render the component",
        "A function to fetch data"
      ],
      "answer": 1,
      "explanation": "`useReducer` returns an array where the second element is a dispatch function. This dispatch function is used to send actions to the reducer, which then updates the state based on the action type."
    },
    {
      "id": 16,
      "question": "Which hook runs synchronously after all DOM mutations?",
      "options": ["useEffect", "useLayoutEffect", "useRef", "useCallback"],
      "answer": 1,
      "explanation": "`useLayoutEffect` runs synchronously after all DOM mutations. This is useful for reading layout from the DOM and synchronously re-rendering. It is similar to `useEffect`, but it fires before the browser paints, making it suitable for measuring DOM elements and making layout adjustments."
    },
    {
      "id": 17,
      "question": "What is the main use case of useImperativeHandle?",
      "options": [
        "To directly modify DOM elements",
        "To customize the instance value exposed by ref",
        "To manage component lifecycle",
        "To optimize rendering performance"
      ],
      "answer": 1,
      "explanation": "`useImperativeHandle` is used to customize the instance value that is exposed when using `ref` with `forwardRef`. It allows parent components to access specific functions or properties of a child component."
    },
    {
      "id": 18,
      "question": "Which hook is useful for performance when passing callback functions to child components?",
      "options": ["useCallback", "useEffect", "useReducer", "useRef"],
      "answer": 0,
      "explanation": "<code>useCallback</code> is useful for optimizing performance when passing callback functions to child components. It memoizes the function so that it does not change on every render, preventing unnecessary re-renders of child components that rely on reference equality.<br><br>Example:<pre><code>// This function is recreated on every render without useCallback\nconst handleClick = () => {\n  console.log('Clicked!');\n};\n\n// This function is only recreated when dependencies change\nconst memoizedHandleClick = useCallback(() => {\n  console.log('Clicked!');\n}, []);</code></pre>"
    },
    {
      "id": 19,
      "question": "Which hook allows sharing state logic across multiple components?",
      "options": [
        "Custom Hooks",
        "useReducer",
        "useLayoutEffect",
        "useContext"
      ],
      "answer": 0,
      "explanation": "Custom Hooks allow you to extract component logic into reusable functions. This makes it easy to share stateful logic between components without repeating code or using render props or higher-order components."
    },
    {
      "id": 20,
      "question": "What is a rule of hooks?",
      "options": [
        "Hooks can only be called inside class components",
        "Hooks can only be called inside function components or custom hooks",
        "Hooks can be called conditionally inside loops",
        "Hooks can be used anywhere in JavaScript"
      ],
      "answer": 1,
      "explanation": "One of the rules of hooks is that they can only be called inside React function components or custom hooks. This ensures that all stateful logic in a component is clearly visible from its source code and helps maintain the correct order of hooks between renders."
    }
  ]
}
